
It is extremely complicated to explicitly represent the body relation during editing.  It may make more sense to simply batch everything as static during editing and eat the cost with each edit.  Rebatch at play_init.

Perhaps maintain separate spaces (or even worlds) for edit and play.  The pointer only works on the edit space.  All edit geoms always exist in edit space, but are not collided during play.  Geoms, bodies, and joints are created and destroyed in play_init and play_fini.  This would have the added effect of helping assure reproducibility.

Even if the body serial number system is retained, it would still make sense to restructure the XML DOM to represent bodies explicitly.  This would remove the need to resolve serial number conflicts on loading.

-------------------------------------------------------------------------------

* Batch batch batch

This sorts vertex array above material...

    prep
        for each dirty body
            for each material
                for each geom with that material
                    append vertices with geom transform pre-applied
                    append indices

    draw
        for each body
            apply the body transform
            bind vertices
            for each material
                draw indices

This sorts material above vertex array...

    prep
        for each dirty body
            for each material
                for each geom with that material
                    append vertices with geom transform pre-applied
                    append indices

    draw
        for each material
            for each body
                apply the body transform
                bind vertices
                draw indices

Three material type become significant
    ambient
    diffuse
    zbuffer

    A depth-only pass requires no texture bindings and thus enables a single
    batch for a large number of surfaces.  Given early-z and shadow, this
    would likely be a significant reduction in batch count.

        The for-each-material steps more quickly in depth mode.

    Of course, the alphatest geometry still requires segmentation by material.

    It may be worth sorting by shader above material.

    Changing transforms is cheaper than changing shaders and materials.
        However sorting transform last undermines front-back ordering.

                                        Disable   Enable
    Material color changes are cheap.   173->180  414->414
    Texture changes are expensive.      173->190  414->260
    Program changes are expensive.      173->243  414->193
    Disabling everything is great!      173->414

Assume a flat scene hierarchy?
    Bounding-box test at batch?
                      at material change?
                      at program change?

-------------------------------------------------------------------------------


Replace widget show() with a parent->poke?
    This would remove the need to pass the root of the control to all create buttons
    group nodes would poke all OTHER children plus parent
Assymmetry with hide() ... only ever called to apply parameters?

The lang dependance could be moved from gui to control.

C++ notes
    Virtual base classes shouldn't have data members?

I often delete members in dtors.  Should these use auto_ptrs?  const ones?
    Don't use auto_ptrs in assumed-assignable objects
        Such as objects you'd flatly add to containers.

Is mutable appropriate anywhere?  (say in glob)  Where const implies policy rather than mechanism?

Bald pointer members (and auto_ptr members) may need copy constructors and copy assignment operators.

Encapsulate GL objects in trivial Gen/Delete wrappers?

Consider using deque vector caches in the OBJ loader.  Profile.

-------------------------------------------------------------------------------

data layout

        ttf

        scene

                funland.xml
                1upia.xml        
                hirubefield.xml

        audio
                music
                sound
                        baz
                                jump1.ogg
                                jump2.ogg

        solid
                plant
                platform
                button
                vehicle
                        jeep_body.obj
                        jeep_tire.obj
                misc
                        box.obj
                        box.mtl
        joint
                joint_ball.obj
                joint_ball.mtl

-------------------------------------------------------------------------------

Physical properties

        global
                ERP
                CFM
                gravity

        entity
                category
                collide
                mass
                bounce
                friction
                conveyer x
                conveyer y
                soft ERP
                soft CFM

        joint
                velocity 1 2 3
                force    1 2 3
                CFM      1 2 3
                lo stop  1 2 3
                hi stop  1 2 3
                bounce   1 2 3
                stop ERP 1 2 3
                stop CFM 1 2 3
                suspension ERP
                suspension CFM


Expression Grammar

        P -> "sin"
        P -> "cos"
        P -> "sqr"
        P -> "tri"
        P -> "saw"

        P -> "key"
        P -> "btn"
        P -> "trg"
        P -> "joy"

        F -> "t"
        F -> "pi"
        F -> "inf"
        F -> [0..9]*
        F -> [0..9]*.[0..9]*

        F -> P ( E )
        F ->   ( E )
        F ->   - E
        T ->   F
        T ->   F * T
        T ->   F / T
        E ->   T
        E ->   T + E
        E ->   T - E

-------------------------------------------------------------------------------

Octree notes

        Needs
                Frustum culling for rendering to camera and lightsource views
                Rubber band selection
                Picking (optionally)
                Front-back sorting
                Invariant preservation is the tough issue
                "All" arbitrary iteration

        ODE planes could do rubber band selection, but probably are not
        appropriate for render culling.

        A log(n) implementation MAY not be a performance improvement
                The tipping point is probably around 1000 objects


        Implementation
                Explicit point representation (PR)
                Recursive AABB subdivision (MX)
                        Doesn't grow as nicely as PR
                Plane straddling could be tough


        Static grid octree or quadtree

                Invariants
                        Each entity is in exactly ONE cell
                        This cell is the smallest that contains the entity

                For each moving entity
                        While the entity is NOT within its current cell
                                Move it up (necessary)

                        If the entity fits within a subcell of the current cell
                                Move it down (optimization)

                Entities outside the static index
                        Sit at the root
                                Root is infinitely large
                or
                        Can't happen
                                ODE planes bound the space
                                This would also allow quadtree space to work

-------------------------------------------------------------------------------



scene
        for each emit
                draw the objects the emit can see to depth

                for each recv
                        for each pass
                                draw the objects the recv can see to color


(water is both a recv (with lower prio than camera) and a draw)

Global view object
        push/pop
        camera entities are allowed to modify it
        light sources can use it for CSM
        entities can check culling against it
        octree can refuse to insert as cull and insert visible in order


light clone (to effect an image dupe)

sampler uniforms

     #   MTL     GLSL        lite  dark
     0   map_Kd  diffuse       *     *
     1   bump    bump          *
     2           light         *
     3           shadow        *
     4   refl    environment   *     *
     5   map_Ke  emission            *
     6   map_Ks  specular      *
     7   map_Ns  shininess     *

                 detail?

** Do NOT render alphatest transparent objects during pre-Z?
   (Z test screws with blending/coverage)

NOTE: alpha testing is NOT blending



solid
    obj type
joint
    gizmo
