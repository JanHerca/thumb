-------------------------------------------------------------------------------

nearest nearest
       PS  61%
       FPS 184
       tex  7%
       rop 14%

linear nearest (+ linear filtering doesn't hurt)
       PS  61%
       FPS 187 
       tex  7%
       rop 14%

nearest linear (- doubling the texture refs has a penalty)
       PS  65%
       FPS 162
       tex  6.5%
       rop 12%

linear linear
       PS  65%
       FPS 162
       tex  6.5%
       rop 12%

nearest nearest with cacheref (+ no change)
       PS  61%
       FPS 184
       tex  7%
       rop 14%

nearest linear with cacheref (+ no change)
       PS  65%
       FPS 162
       tex  6.5%
       rop 12%

nearest linear with data_over_tile (+ slightly better)
       PS  64%
       FPS 167
       tex  6.3%
       rop 13%

nearest linear with rp2 lookup (- worse!)
       PS  66%
       FPS 164
       tex 5.7%
       rop 12%

nearest linear with data_over_tile_base (+ nicely better!)
       PS  63%
       FPS 178
       tex  7.1%
       rop 13%

with fwidth (+ nice speedup, - some quality degradation)
       PS  60%
       FPS 188
       tex  7.5%
       rop 14%

with tile/step/page_over_pool (= no change)
       PS  60%
       FPS 189
       tex  7.5%
       rop 14%

nearest nearest after all that
       PS  58%
       FPS 209
       tex  8%
       rop 16%

nearest nearest L = 0
       PS  51%
       FPS 236
       tex 9.3%
       rop 18%

dif + nrm linear
       FPS 105

dif + nrm nearest
       FPS 130

dif + nrm best
       FPS 143

To try:
    reduce mipref to 2 texrefs and fps goes up 178 to 183
    short mipmap?

-------------------------------------------------------------------------------

cyl   0 (drawdif/drawnrm)
src   0 (calcacc)
index 1
cache 2
rp2   3
pos   4 (calcacc)
nrm   5 (calcacc)
tex   6 (calcacc)

-------------------------------------------------------------------------------

Loader thread:

    Find a page which is listed in the index but not in the cache

    Sort pages by... depth (higher d values earlier)
                     angle (larger first)
        heigher D implies higher A
        so... just A then?

-------------------------------------------------------------------------------

test1.dat geocsh initially working
test2.dat eliminate data copy from load_png
test3.dat implement image buffer pool
test4.dat same (vsync on)
          processor contention is killing png load
test5.dat single mipmap blit instead of multiple
test6.dat some (vsync on)
          consolidating image updates helps!  (a little)

-------------------------------------------------------------------------------


Abstract hierarchical data structure:

    arity
    constraint function
        eg: parents-of-leaves must be represented
        eg: cousins must be within depth 1
    set size
    node weighting function

iterate:
    recompute the weights of all nodes
    resolve for the optimal subset of the given size

Constant storage, amortized constant update time

-------------------------------------------------------------------------------

For each map
    Add the root page to the catalog
    Compute its weight

WHILE there's space left in the catalog
    Find the worst page in the catalog
    IF none was found
        BREAK
    ELSE
        FOR each subdivision
            IF the subdivision is visible AND there is cache space
                Add it to the catalog
                Compute its weight

FOR each page in the catalog
    IF the page is in the cache
        Move it to the front of the LRU queue
    ELSE
        IF the page has not been requested
            Request the page

FOR each loaded page
    Delete the LRU page from the cache and the LRU queue
    Notify its map of the deletion
    Insert the new page into the cache and the LRU queue
    Notify its map of the insertion

-------------------------------------------------------------------------------

Note: if a parent map is visible then at least one of its children is visible.
    (this is not the case with patches)

WHILE there's space left in the cache
    Find the single largest divisible texel on the screen
    IF none was found
        BREAK
    ELSE
        FOR each subdivision
            IF the subdivision is visible AND there is cache space
                Add it to the cache

The largest texel will have the smallest normalized texcoord derivative.

-------------------------------------------------------------------------------

All nodes are ordered.  They may be compared for significance.

** It is not actually necessary to compute the significance of a node, it is only necessary to compare the significance of two nodes.

Significance is defined by the quantity of error that a node introduces.

The primary constraint is the number of nodes.

The secondary constraint for patches is: they must be within one level of their neighbor in depth.

The secondary constraint for pages is: their ancestor must be included.
    (This is not strictly true. The lower-res page must be included, but there is a good chance the lower-res page for THAT must be included as well, etc...)

Sort, add, and remove... THEN chop at the limit.  Hopefully then the failed constraints will occur among the less significant nodes.

When counting patches, once counts the leaves.  When counting images, one counts all nodes.


General dumb approach for images:

    enqueue the root
    initialize the output list to contain only the root

    while the queue is not empty and the output list has fewer than N nodes
        dequeue a node
        for each subdivision of that node
            if the subdivision is visible
                add it to the output list
                enqueue it (with priority)

General dumb approach for patches:

    for each of the 20 root nodes
        if the node is visible
            enqueue it

    while the queue has more than 0 and less than N nodes
        dequeue the highest priority node
        for each subdivision of that node
            if the subdivision is visible
                enqueue it

(this is an extremely clever means of ensuring that a patch with a loose bound giving erroneous visibility is omitted)

-------------------------------------------------------------------------------


geomap properties

    w ... columns
    h ... rows
    c ... channels per pixel
    b ... bytes per channel
    p ... page size in pixels

geomap access

    s ... normalized col-wise coordinate
    t ... normalized row-wise coordinate
    l ... mipmap level

geomap temporaries

    x ... normalized page local col-wise coordinate
    y ... normalized page local row-wise coordinate
    i ... page row
    j ... page column


x =  frac((w * s) / (p * 2^l))
j = floor((w * s) / (p * 2^l))

y =  frac((h * t) / (p * 2^l))
i = floor((h * t) / (p * 2^l))

P.rgb  = I(i, j, l)

D.rgba = C(P.x * p + x,
           P.y * p + y)

I index is a 3D texture... [ceil(w/p), ceil(h/p), log2(max(w, h))]
     or is a 2D texture with by-hand mipmapping

C cache is a 2D texture... [p * n, P * m]

Where n and m are the cache extents in pages.

-------------------------------------------------------------------------------

non-root tile configs aren't written
edges are not straight lines, at least not before sphere correction
interactive FOV and off-axis tweaking may help
frustum rotation tweaks should occur in local rotation frame to avoid gimbal lock

-------------------------------------------------------------------------------
tile render direct

    render cyl/norm/dif to offscreen
    render offscreen to onscreen             k/d

tile render deferred

    render cyl/norm/dif to offscreen
    render offscreen to offscreen left       1/0
    render cyl/norm/dif to offscreen
    render offscreen to offscreen right      1/0
    render offscreen left/right to onscreen  k/d
    

-------------------------------------------------------------------------------

NOTE: the GF6 can filter FP16 textures?
    at least test the performance of 16 versus 32

idea:
    render a page with
        shader enabled
        color write true
        depth test less
        depth write false
        alpha test on
        stencil test equal 0
        stencil keep keep incr
    render a quad at 0 with
        shader disabled
        color write false
        depth write true
        depth test off
        alpha test off
        stencil test equal 1
        stencil keep keep keep

    (stencil counts depth, which is useless, but cool)

Z-cull

    no alpha test
    no discard
    no depth replace
    no alpha-to-coverage
    no depth WRITE

    ARB_position_invariant?    

    If stencil, clear both depth and stencil in the same glClear

GPU Gems 2 Ch 30: Also, in cases where stencil is not being updated, early stencil reject can be employed to remove rendering early when stencil test (based on equals comparison) fails.

On nvidia hardware, you cannot use early-z if rejection of a fragment would still lead to changes in depth/stencil/color. So basically, if you modify stencil on depth fail, you won't get early-z.

Stencil test is fine. Stencil write is only a problem together with alpha test. Stencil op other than KEEP for fail and zFail disables Hierarchical-Z.

http://www.gpgpu.org/forums/viewtopic.php?t=361
http://www.gpgpu.org/forums/viewtopic.php?t=256
http://www.gpgpu.org/forums/viewtopic.php?t=367 

-------------------------------------------------------------------------------
Can coins be instanced?

Can texture atlasing be automated?

-------------------------------------------------------------------------------

Multiple vector accumulations in calcacc will be unstable.  Perhaps accumulate the radius only in W, and compute the true position in a vertex shader.

The extrema calculation and readback could be eliminated by computing extrema during heightmap accumulation.  The bounds would not be as tight, but it would be close, and skipping the readback would be a huge win.  The Z planes will have to be computed by hand the old way.

Consider HILO_NV for normal storage.  The z component is computed automatically.

We're pixel/texture limited.  Compress.

In the future, the extrema reducer could computer tighter NDC coverage.

Support for alpha test for a particular format may be associated with support for blending on that format.  So alpha testing heightmaps might not work.

-------------------------------------------------------------------------------

sphere balance

    bias depth count VRAM
    15   4     1024  131  original
    1.5  5     128   90   much fewer batches
    1.5  4     128   61   giant triangles, very fast

    bias < ~1.5 cannot guarantee adjacent patches are within 1 LOD

-------------------------------------------------------------------------------

Exploitable commonality between tiles and eyes

    Extremely similar height/color/normal usage between eyes
    Neighboring height/color/normal usage between eyes
    Common stereo pass

Be sure to allow for multiple render threads per host
    Vellum has 2 GPUs... they should be totally independant
    Though it would be advantageous to have only one data access thread

-------------------------------------------------------------------------------

Replace widget show() with a parent->poke?
    This would remove the need to pass the root of the control to all create buttons
    group nodes would poke all OTHER children plus parent
Assymmetry with hide() ... only ever called to apply parameters?

The lang dependance could be moved from gui to control.

C++ notes
    Virtual base classes shouldn't have data members?

I often delete members in dtors.  Should these use auto_ptrs?  const ones?
    Don't use auto_ptrs in assumed-assignable objects
        Such as objects you'd flatly add to containers.

Is mutable appropriate anywhere?  (say in glob)  Where const implies policy rather than mechanism?

Bald pointer members (and auto_ptr members) may need copy constructors and copy assignment operators.

Encapsulate GL objects in trivial Gen/Delete wrappers?

Consider using deque vector caches in the OBJ loader.  Profile.

-------------------------------------------------------------------------------

data layout

        ttf

        scene

                funland.xml
                1upia.xml        
                hirubefield.xml

        audio
                music
                sound
                        baz
                                jump1.ogg
                                jump2.ogg

        solid
                plant
                platform
                button
                vehicle
                        jeep_body.obj
                        jeep_tire.obj
                misc
                        box.obj
                        box.mtl
        joint
                joint_ball.obj
                joint_ball.mtl

-------------------------------------------------------------------------------

Physical properties

        global
                ERP
                CFM
                gravity

        entity
                category
                collide
                mass
                bounce
                friction
                conveyer x
                conveyer y
                soft ERP
                soft CFM

        joint
                velocity 1 2 3
                force    1 2 3
                CFM      1 2 3
                lo stop  1 2 3
                hi stop  1 2 3
                bounce   1 2 3
                stop ERP 1 2 3
                stop CFM 1 2 3
                suspension ERP
                suspension CFM


Expression Grammar

        P -> "sin"
        P -> "cos"
        P -> "sqr"
        P -> "tri"
        P -> "saw"

        P -> "key"
        P -> "btn"
        P -> "trg"
        P -> "joy"

        F -> "t"
        F -> "pi"
        F -> "inf"
        F -> [0..9]*
        F -> [0..9]*.[0..9]*

        F -> P ( E )
        F ->   ( E )
        F ->   - E
        T ->   F
        T ->   F * T
        T ->   F / T
        E ->   T
        E ->   T + E
        E ->   T - E

-------------------------------------------------------------------------------

Octree notes

        Needs
                Frustum culling for rendering to camera and lightsource views
                Rubber band selection
                Picking (optionally)
                Front-back sorting
                Invariant preservation is the tough issue
                "All" arbitrary iteration

        ODE planes could do rubber band selection, but probably are not
        appropriate for render culling.

        A log(n) implementation MAY not be a performance improvement
                The tipping point is probably around 1000 objects


        Implementation
                Explicit point representation (PR)
                Recursive AABB subdivision (MX)
                        Doesn't grow as nicely as PR
                Plane straddling could be tough


        Static grid octree or quadtree

                Invariants
                        Each entity is in exactly ONE cell
                        This cell is the smallest that contains the entity

                For each moving entity
                        While the entity is NOT within its current cell
                                Move it up (necessary)

                        If the entity fits within a subcell of the current cell
                                Move it down (optimization)

                Entities outside the static index
                        Sit at the root
                                Root is infinitely large
                or
                        Can't happen
                                ODE planes bound the space
                                This would also allow quadtree space to work

-------------------------------------------------------------------------------


  (\_
 ()_

  (\_
 (]_

  (\
 (]_

  (\
 [)_

  (\
 []_

  (\
 [)_ THUMB

