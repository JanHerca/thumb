

tile render direct

    render cyl/norm/dif to offscreen
    render offscreen to onscreen             k/d

tile render deferred

    render cyl/norm/dif to offscreen
    render offscreen to offscreen left       1/0
    render cyl/norm/dif to offscreen
    render offscreen to offscreen right      1/0
    render offscreen left/right to onscreen  k/d
    

-------------------------------------------------------------------------------

NOTE: the GF6 can filter FP16 textures?
    at least test the performance of 16 versus 32

idea:
    render a page with
        shader enabled
        color write true
        depth test less
        depth write false
        alpha test on
        stencil test equal 0
        stencil keep keep incr
    render a quad at 0 with
        shader disabled
        color write false
        depth write true
        depth test off
        alpha test off
        stencil test equal 1
        stencil keep keep keep

    (stencil counts depth, which is useless, but cool)

Z-cull

    no alpha test
    no discard
    no depth replace
    no alpha-to-coverage
    no depth WRITE

    ARB_position_invariant?    

    If stencil, clear both depth and stencil in the same glClear

GPU Gems 2 Ch 30: Also, in cases where stencil is not being updated, early stencil reject can be employed to remove rendering early when stencil test (based on equals comparison) fails.

On nvidia hardware, you cannot use early-z if rejection of a fragment would still lead to changes in depth/stencil/color. So basically, if you modify stencil on depth fail, you won't get early-z.

Stencil test is fine. Stencil write is only a problem together with alpha test. Stencil op other than KEEP for fail and zFail disables Hierarchical-Z.

http://www.gpgpu.org/forums/viewtopic.php?t=361
http://www.gpgpu.org/forums/viewtopic.php?t=256
http://www.gpgpu.org/forums/viewtopic.php?t=367 

-------------------------------------------------------------------------------
Can coins be instanced?

Can texture atlasing be automated?

-------------------------------------------------------------------------------

Multiple vector accumulations in calcacc will be unstable.  Perhaps accumulate the radius only in W, and compute the true position in a vertex shader.

The extrema calculation and readback could be eliminated by computing extrema during heightmap accumulation.  The bounds would not be as tight, but it would be close, and skipping the readback would be a huge win.  The Z planes will have to be computed by hand the old way.

Consider HILO_NV for normal storage.  The z component is computed automatically.

We're pixel/texture limited.  Compress.

In the future, the extrema reducer could computer tighter NDC coverage.

Support for alpha test for a particular format may be associated with support for blending on that format.  So alpha testing heightmaps might not work.

-------------------------------------------------------------------------------

sphere balance

    bias depth count VRAM
    15   4     1024  131  original
    1.5  5     128   90   much fewer batches
    1.5  4     128   61   giant triangles, very fast

    bias < ~1.5 cannot guarantee adjacent patches are within 1 LOD

-------------------------------------------------------------------------------

Exploitable commonality between tiles and eyes

    Extremely similar height/color/normal usage between eyes
    Neighboring height/color/normal usage between eyes
    Common stereo pass

Be sure to allow for multiple render threads per host
    Vellum has 2 GPUs... they should be totally independant
    Though it would be advantageous to have only one data access thread

-------------------------------------------------------------------------------

Replace widget show() with a parent->poke?
    This would remove the need to pass the root of the control to all create buttons
    group nodes would poke all OTHER children plus parent
Assymmetry with hide() ... only ever called to apply parameters?

The lang dependance could be moved from gui to control.

C++ notes
    Virtual base classes shouldn't have data members?

I often delete members in dtors.  Should these use auto_ptrs?  const ones?
    Don't use auto_ptrs in assumed-assignable objects
        Such as objects you'd flatly add to containers.

Is mutable appropriate anywhere?  (say in glob)  Where const implies policy rather than mechanism?

Bald pointer members (and auto_ptr members) may need copy constructors and copy assignment operators.

Encapsulate GL objects in trivial Gen/Delete wrappers?

Consider using deque vector caches in the OBJ loader.  Profile.

-------------------------------------------------------------------------------

data layout

        ttf

        scene

                funland.xml
                1upia.xml        
                hirubefield.xml

        audio
                music
                sound
                        baz
                                jump1.ogg
                                jump2.ogg

        solid
                plant
                platform
                button
                vehicle
                        jeep_body.obj
                        jeep_tire.obj
                misc
                        box.obj
                        box.mtl
        joint
                joint_ball.obj
                joint_ball.mtl

-------------------------------------------------------------------------------

Physical properties

        global
                ERP
                CFM
                gravity

        entity
                category
                collide
                mass
                bounce
                friction
                conveyer x
                conveyer y
                soft ERP
                soft CFM

        joint
                velocity 1 2 3
                force    1 2 3
                CFM      1 2 3
                lo stop  1 2 3
                hi stop  1 2 3
                bounce   1 2 3
                stop ERP 1 2 3
                stop CFM 1 2 3
                suspension ERP
                suspension CFM


Expression Grammar

        P -> "sin"
        P -> "cos"
        P -> "sqr"
        P -> "tri"
        P -> "saw"

        P -> "key"
        P -> "btn"
        P -> "trg"
        P -> "joy"

        F -> "t"
        F -> "pi"
        F -> "inf"
        F -> [0..9]*
        F -> [0..9]*.[0..9]*

        F -> P ( E )
        F ->   ( E )
        F ->   - E
        T ->   F
        T ->   F * T
        T ->   F / T
        E ->   T
        E ->   T + E
        E ->   T - E

-------------------------------------------------------------------------------

Octree notes

        Needs
                Frustum culling for rendering to camera and lightsource views
                Rubber band selection
                Picking (optionally)
                Front-back sorting
                Invariant preservation is the tough issue
                "All" arbitrary iteration

        ODE planes could do rubber band selection, but probably are not
        appropriate for render culling.

        A log(n) implementation MAY not be a performance improvement
                The tipping point is probably around 1000 objects


        Implementation
                Explicit point representation (PR)
                Recursive AABB subdivision (MX)
                        Doesn't grow as nicely as PR
                Plane straddling could be tough


        Static grid octree or quadtree

                Invariants
                        Each entity is in exactly ONE cell
                        This cell is the smallest that contains the entity

                For each moving entity
                        While the entity is NOT within its current cell
                                Move it up (necessary)

                        If the entity fits within a subcell of the current cell
                                Move it down (optimization)

                Entities outside the static index
                        Sit at the root
                                Root is infinitely large
                or
                        Can't happen
                                ODE planes bound the space
                                This would also allow quadtree space to work

-------------------------------------------------------------------------------


  (\_
 ()_

  (\_
 (]_

  (\
 (]_

  (\
 [)_

  (\
 []_

  (\
 [)_ THUMB

