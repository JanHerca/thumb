-------------------------------------------------------------------------------

Separating the engine from the application

    Compile all modules down to a library
    Isolate all the headers

    A lot of the stuff in main should be moved to app-prog
       Is "app-exec" a better name?
       Is "app-main" a better name?

    Rename app-serial to "app-file".

    Make it possible for the application to add data directories
        Each data directory may have its own data config file

    Think hard about the global objects

        the application MUST instantiate the app-prog
        the prog is the LAST of the global objects instantiated

        order:
            data
            conf   // loads XML via data
            lang   // selects file via conf and loads via data
            host   // selects file via conf and loads via data

            video()

            user   // selects file via conf and loads via data
            glob   // loads via data, currently needs GL context
            perf
            prog   // configures via conf and loads via glob

    video() should be moved to app::host
        This would also provide host with the ability to bound the video
        on configuration change.

    Decide where SDL goes
        Either ONLY in the application or ONLY in the library

    A serious rewrite of glob handling would allow GL objects to be created
    in the absense of a context, relaxing the restrictions of prog creation
    time.

-------------------------------------------------------------------------------

XBox 360 Controller

    Axis
    0    Left  stick X    (1 is right, -1 is left)
    1    Left  stick Y    (1 is down,  -1 is up)
    2    Right stick X    (1 is right, -1 is left)
    3    Right stick Y    (1 is down,  -1 is up)
    4    Left  trigger    (1 is pressed, -1 is released)
    5    Right trigger    (1 is pressed, -1 is released)

    Button
    0    Digital pad up
    1    Digital pad down
    2    Digital pad left
    3    Digital pad right
    4    Start
    5    Back
    6    Left  stick
    7    Right stick
    8    Left  shoulder
    9    Right shoulder
    10   Logo
    11   A
    12   B
    13   X
    14   Y

-------------------------------------------------------------------------------

Events

    point
        i device index
        p position
        q orientation
    click
        i device index
        b button number
        m modifier state
        d up/down
    keybd
        c character
        k key
        m modifier state
        d up/down
    timer
        t time passed in milliseconds
    value
        d device index
        a axis index
        v value
    messg
        input  buffer
        output buffer
    paint
    front/frame
    start
    close
  * enter
  * leave

  * Does not correspond to a host message

    Devices must be able to translate from one event type to another and
    forward the translation back through the host.

    The host encodes and decodes events to a binary buffer.

    Return values:

        The event has dirtied the screen
        I have handled the event

    The message event produces a response

    Point events entail the conversion from (x,y) to (p,q) and back

    Modes take
        enter
        leave

    Stateful objects take
        start
        close

-------------------------------------------------------------------------------

plot [0:4800][0:33] "test-8800-1024" using 1:2 with lines, "test-8800-1024" using 1:3 with lines

-------------------------------------------------------------------------------

A page of data is needed if
    There exists a frustum such that
        The page is visible
        The average page res ratio (texels per screen pixel) is less than 4

compute the solid angle of each frustum to get res ratio?

geomap::view
    iterate the page tree
        from the root to the res limit
            test pages for neededness using the sphere's transform
            if needed
                if state is "needed", keep it
                if state is "loading", keep it
                if state is "default", set "needed"
            else
                set state to "default"
                (note, do not eject if loaded)

How do "needed" pages get reset to "default" when they fall out of view?
    With a needed set (reasonably fast insert and delete)
        Which is iterated with each tested.
    
geocsh::get_needed
    dequeue (and map) a buff
    find the "most" "needed" page in any geomap
        mark that page "loading"

loader_func
    geocsh::get_needed
    load the page into the buff
    enqueue a load

geocsh::proc_loads
    if the cache is full
        find the LRU page
        eject it and mark it "default"
    upload the page to the cache
    mark the page "loaded"
    enqueue a buff


* merge wait with buff

-------------------------------------------------------------------------------

Could the cracking problem be mitigated by explicitly rounding height positions to the enarest integral pixel?  Is it the nearest logic of the hardware that is the problem?  Would the floor(x + 0.5) approach be more stable?  Pass (w,h) and quantize the normalized coordinate.  Should be no perf penalty, as it's only necessary in calcacc.  Answer: NO.

Create "full" versions of calcacc, drawdif, and drawnrm that don't check their bounds.

Benchmark blending versus discard. Alpha can be raised to a power to penalize border blends.

Alternatively, look into clamping the mipmap index to a border.  Is there a cache coordinate that can always be used as out of bounds?

Modify the image buffer of the mipmap index to use a mapped PBO. Modyfy it freely, umap and blit at proc. Map on first need next frame. This will require read mapping as well as write, and will be somewhat not-sequential, so it may are may not be an improvement. However, it will eliminate a large data copy.

-------------------------------------------------------------------------------

Fast texture upload formats?

internal   type                          external
GL_RGB5    GL_UNSIGNED_SHORT_5_6_5       GL_RGB
GL_RGB8    GL_UNSIGNED_INT_8_8_8_8_REV   GL_BGRA
GL_RGBA4   GL_UNSIGNED_SHORT_4_4_4_4_REV GL_BGRA
GL_RGB5_A1 GL_UNSIGNED_SHORT_1_5_5_5_REV GL_BGRA
GL_RGBA8   GL_UNSIGNED_INT_8_8_8_8_REV   GL_BGRA

-------------------------------------------------------------------------------

NOTE: round to nearest = floor(x + 0.5)

-------------------------------------------------------------------------------

step
    foreach csh
        csh.init
    foreach map
        map.csh.seed(vp, r0, r1, map)
    foreach csh
        csh.proc
    foreach map
        map.proc

draw
    foreach map type
        foreach map
            map.shd.bind()
            map.csh.bind()
            map.uniform(map.csh.pool_w, map.csh.pool_w)
            map.draw()
            map.csh.free()
            map.shd.free()

-------------------------------------------------------------------------------

step
    csh.init()
    csh.seed(map)
    csh.proc()
    map.proc()

prep
    height draw

draw
    shd.bind()
    csh.bind()
    map.uniform(csh.pool_w, csh.pool_h)
    map.draw()
    csh.free()
    shd.free()

-------------------------------------------------------------------------------

vellum no sync

128/4 8x8 8x4 nearest 640x480   59ms
128/3 8x8 8x4 nearest 640x480   49ms
 64/4 8x8 8x4 nearest 640x480   54ms
 64/3 8x8 8x4 nearest 640x480   48ms
 64/3 8x8 8x4 best    640x480   44ms
 64/3 8x4 8x4 best    640x480   44ms
 64/3 8x8 8x8 best    640x480   44ms
256/3 8x8 8x8 best    640x480   52ms
256/3 8x8 8x8 linear  640x480   63ms
256/3 8x8 8x8 best    320x240   39ms
256/3 8x8 8x8 best    512x384   43ms
256/3 8x8 8x8 best    640x480   50ms  optimization C.xy + 1
256/3 8x8 8x8 best    640x480   50ms  optimization over_pool
256/3 8x8 8x8 best    640x480   38ms  atmo 0
256/3 8x8 8x8 best    640x480   42ms  reduced sphere

-------------------------------------------------------------------------------

nearest nearest
       PS  61%
       FPS 184
       tex  7%
       rop 14%

linear nearest (+ linear filtering doesn't hurt)
       PS  61%
       FPS 187 
       tex  7%
       rop 14%

nearest linear (- doubling the texture refs has a penalty)
       PS  65%
       FPS 162
       tex  6.5%
       rop 12%

linear linear
       PS  65%
       FPS 162
       tex  6.5%
       rop 12%

nearest nearest with cacheref (+ no change)
       PS  61%
       FPS 184
       tex  7%
       rop 14%

nearest linear with cacheref (+ no change)
       PS  65%
       FPS 162
       tex  6.5%
       rop 12%

nearest linear with data_over_tile (+ slightly better)
       PS  64%
       FPS 167
       tex  6.3%
       rop 13%

nearest linear with rp2 lookup (- worse!)
       PS  66%
       FPS 164
       tex 5.7%
       rop 12%

nearest linear with data_over_tile_base (+ nicely better!)
       PS  63%
       FPS 178
       tex  7.1%
       rop 13%

with fwidth (+ nice speedup, - some quality degradation)
       PS  60%
       FPS 188
       tex  7.5%
       rop 14%

with tile/step/page_over_pool (= no change)
       PS  60%
       FPS 189
       tex  7.5%
       rop 14%

nearest nearest after all that
       PS  58%
       FPS 209
       tex  8%
       rop 16%

nearest nearest L = 0
       PS  51%
       FPS 236
       tex 9.3%
       rop 18%

dif + nrm linear
       FPS 105

dif + nrm nearest
       FPS 130

dif + nrm best
       FPS 143

dif + nrm + acc nearest
       FPS 128

Full function best 128/3
       SoCal   136
       Rainier 143
     
Full function best 128/4
       SoCal   112
       Rainier 116
     
Full function + ext (unread) best 128/3
       SoCal   130
       Rainier 137
     
Full function + ext (unread) best 128/4
       SoCal   102
       Rainier 110
     
Full function + ext best 128/3
       SoCal   139
       Rainier 135
     

To try:
    reduce mipref to 2 texrefs and fps goes up 178 to 183
    short mipmap?

-------------------------------------------------------------------------------

cyl   0 (drawdif/drawnrm)
src   0 (calcacc)
index 1
cache 2
rp2   3
pos   4 (calcacc)
nrm   5 (calcacc)
tex   6 (calcacc)

-------------------------------------------------------------------------------

Loader thread:

    Find a page which is listed in the index but not in the cache

    Sort pages by... depth (higher d values earlier)
                     angle (larger first)
        heigher D implies higher A
        so... just A then?

-------------------------------------------------------------------------------

test1.dat geocsh initially working
test2.dat eliminate data copy from load_png
test3.dat implement image buffer pool
test4.dat same (vsync on)
          processor contention is killing png load
test5.dat single mipmap blit instead of multiple
test6.dat some (vsync on)
          consolidating image updates helps!  (a little)

-------------------------------------------------------------------------------


Abstract hierarchical data structure:

    arity
    constraint function
        eg: parents-of-leaves must be represented
        eg: cousins must be within depth 1
    set size
    node weighting function

iterate:
    recompute the weights of all nodes
    resolve for the optimal subset of the given size

Constant storage, amortized constant update time

-------------------------------------------------------------------------------

For each map
    Add the root page to the catalog
    Compute its weight

WHILE there's space left in the catalog
    Find the worst page in the catalog
    IF none was found
        BREAK
    ELSE
        FOR each subdivision
            IF the subdivision is visible AND there is cache space
                Add it to the catalog
                Compute its weight

FOR each page in the catalog
    IF the page is in the cache
        Move it to the front of the LRU queue
    ELSE
        IF the page has not been requested
            Request the page

FOR each loaded page
    Delete the LRU page from the cache and the LRU queue
    Notify its map of the deletion
    Insert the new page into the cache and the LRU queue
    Notify its map of the insertion

-------------------------------------------------------------------------------

Note: if a parent map is visible then at least one of its children is visible.
    (this is not the case with patches)

WHILE there's space left in the cache
    Find the single largest divisible texel on the screen
    IF none was found
        BREAK
    ELSE
        FOR each subdivision
            IF the subdivision is visible AND there is cache space
                Add it to the cache

The largest texel will have the smallest normalized texcoord derivative.

-------------------------------------------------------------------------------

All nodes are ordered.  They may be compared for significance.

** It is not actually necessary to compute the significance of a node, it is only necessary to compare the significance of two nodes.

Significance is defined by the quantity of error that a node introduces.

The primary constraint is the number of nodes.

The secondary constraint for patches is: they must be within one level of their neighbor in depth.

The secondary constraint for pages is: their ancestor must be included.
    (This is not strictly true. The lower-res page must be included, but there is a good chance the lower-res page for THAT must be included as well, etc...)

Sort, add, and remove... THEN chop at the limit.  Hopefully then the failed constraints will occur among the less significant nodes.

When counting patches, once counts the leaves.  When counting images, one counts all nodes.


General dumb approach for images:

    enqueue the root
    initialize the output list to contain only the root

    while the queue is not empty and the output list has fewer than N nodes
        dequeue a node
        for each subdivision of that node
            if the subdivision is visible
                add it to the output list
                enqueue it (with priority)

General dumb approach for patches:

    for each of the 20 root nodes
        if the node is visible
            enqueue it

    while the queue has more than 0 and less than N nodes
        dequeue the highest priority node
        for each subdivision of that node
            if the subdivision is visible
                enqueue it

(this is an extremely clever means of ensuring that a patch with a loose bound giving erroneous visibility is omitted)

-------------------------------------------------------------------------------


geomap properties

    w ... columns
    h ... rows
    c ... channels per pixel
    b ... bytes per channel
    p ... page size in pixels

geomap access

    s ... normalized col-wise coordinate
    t ... normalized row-wise coordinate
    l ... mipmap level

geomap temporaries

    x ... normalized page local col-wise coordinate
    y ... normalized page local row-wise coordinate
    i ... page row
    j ... page column


x =  frac((w * s) / (p * 2^l))
j = floor((w * s) / (p * 2^l))

y =  frac((h * t) / (p * 2^l))
i = floor((h * t) / (p * 2^l))

P.rgb  = I(i, j, l)

D.rgba = C(P.x * p + x,
           P.y * p + y)

I index is a 3D texture... [ceil(w/p), ceil(h/p), log2(max(w, h))]
     or is a 2D texture with by-hand mipmapping

C cache is a 2D texture... [p * n, P * m]

Where n and m are the cache extents in pages.

-------------------------------------------------------------------------------

non-root tile configs aren't written
edges are not straight lines, at least not before sphere correction
interactive FOV and off-axis tweaking may help
frustum rotation tweaks should occur in local rotation frame to avoid gimbal lock

-------------------------------------------------------------------------------
tile render direct

    render cyl/norm/dif to offscreen
    render offscreen to onscreen             k/d

tile render deferred

    render cyl/norm/dif to offscreen
    render offscreen to offscreen left       1/0
    render cyl/norm/dif to offscreen
    render offscreen to offscreen right      1/0
    render offscreen left/right to onscreen  k/d
    

-------------------------------------------------------------------------------

NOTE: the GF6 can filter FP16 textures?
    at least test the performance of 16 versus 32

idea:
    render a page with
        shader enabled
        color write true
        depth test less
        depth write false
        alpha test on
        stencil test equal 0
        stencil keep keep incr
    render a quad at 0 with
        shader disabled
        color write false
        depth write true
        depth test off
        alpha test off
        stencil test equal 1
        stencil keep keep keep

    (stencil counts depth, which is useless, but cool)

Z-cull

    no alpha test
    no discard
    no depth replace
    no alpha-to-coverage
    no depth WRITE

    ARB_position_invariant?    

    If stencil, clear both depth and stencil in the same glClear

GPU Gems 2 Ch 30: Also, in cases where stencil is not being updated, early stencil reject can be employed to remove rendering early when stencil test (based on equals comparison) fails.

On nvidia hardware, you cannot use early-z if rejection of a fragment would still lead to changes in depth/stencil/color. So basically, if you modify stencil on depth fail, you won't get early-z.

Stencil test is fine. Stencil write is only a problem together with alpha test. Stencil op other than KEEP for fail and zFail disables Hierarchical-Z.

http://www.gpgpu.org/forums/viewtopic.php?t=361
http://www.gpgpu.org/forums/viewtopic.php?t=256
http://www.gpgpu.org/forums/viewtopic.php?t=367 

-------------------------------------------------------------------------------
Can coins be instanced?

Can texture atlasing be automated?

-------------------------------------------------------------------------------

Multiple vector accumulations in calcacc will be unstable.  Perhaps accumulate the radius only in W, and compute the true position in a vertex shader.

The extrema calculation and readback could be eliminated by computing extrema during heightmap accumulation.  The bounds would not be as tight, but it would be close, and skipping the readback would be a huge win.  The Z planes will have to be computed by hand the old way.

Consider HILO_NV for normal storage.  The z component is computed automatically.

We're pixel/texture limited.  Compress.

In the future, the extrema reducer could computer tighter NDC coverage.

Support for alpha test for a particular format may be associated with support for blending on that format.  So alpha testing heightmaps might not work.

-------------------------------------------------------------------------------

sphere balance

    bias depth count VRAM
    15   4     1024  131  original
    1.5  5     128   90   much fewer batches
    1.5  4     128   61   giant triangles, very fast

    bias < ~1.5 cannot guarantee adjacent patches are within 1 LOD

-------------------------------------------------------------------------------

Exploitable commonality between tiles and eyes

    Extremely similar height/color/normal usage between eyes
    Neighboring height/color/normal usage between eyes
    Common stereo pass

Be sure to allow for multiple render threads per host
    Vellum has 2 GPUs... they should be totally independant
    Though it would be advantageous to have only one data access thread

-------------------------------------------------------------------------------

Replace widget show() with a parent->poke?
    This would remove the need to pass the root of the control to all create buttons
    group nodes would poke all OTHER children plus parent
Assymmetry with hide() ... only ever called to apply parameters?

The lang dependance could be moved from gui to control.

C++ notes
    Virtual base classes shouldn't have data members?

I often delete members in dtors.  Should these use auto_ptrs?  const ones?
    Don't use auto_ptrs in assumed-assignable objects
        Such as objects you'd flatly add to containers.

Is mutable appropriate anywhere?  (say in glob)  Where const implies policy rather than mechanism?

Bald pointer members (and auto_ptr members) may need copy constructors and copy assignment operators.

Encapsulate GL objects in trivial Gen/Delete wrappers?

Consider using deque vector caches in the OBJ loader.  Profile.

-------------------------------------------------------------------------------

data layout

        ttf

        scene

                funland.xml
                1upia.xml        
                hirubefield.xml

        audio
                music
                sound
                        baz
                                jump1.ogg
                                jump2.ogg

        solid
                plant
                platform
                button
                vehicle
                        jeep_body.obj
                        jeep_tire.obj
                misc
                        box.obj
                        box.mtl
        joint
                joint_ball.obj
                joint_ball.mtl

-------------------------------------------------------------------------------

Physical properties

        global
                ERP
                CFM
                gravity

        entity
                category
                collide
                mass
                bounce
                friction
                conveyer x
                conveyer y
                soft ERP
                soft CFM

        joint
                velocity 1 2 3
                force    1 2 3
                CFM      1 2 3
                lo stop  1 2 3
                hi stop  1 2 3
                bounce   1 2 3
                stop ERP 1 2 3
                stop CFM 1 2 3
                suspension ERP
                suspension CFM


Expression Grammar

        P -> "sin"
        P -> "cos"
        P -> "sqr"
        P -> "tri"
        P -> "saw"

        P -> "key"
        P -> "btn"
        P -> "trg"
        P -> "joy"

        F -> "t"
        F -> "pi"
        F -> "inf"
        F -> [0..9]*
        F -> [0..9]*.[0..9]*

        F -> P ( E )
        F ->   ( E )
        F ->   - E
        T ->   F
        T ->   F * T
        T ->   F / T
        E ->   T
        E ->   T + E
        E ->   T - E

-------------------------------------------------------------------------------

Octree notes

        Needs
                Frustum culling for rendering to camera and lightsource views
                Rubber band selection
                Picking (optionally)
                Front-back sorting
                Invariant preservation is the tough issue
                "All" arbitrary iteration

        ODE planes could do rubber band selection, but probably are not
        appropriate for render culling.

        A log(n) implementation MAY not be a performance improvement
                The tipping point is probably around 1000 objects


        Implementation
                Explicit point representation (PR)
                Recursive AABB subdivision (MX)
                        Doesn't grow as nicely as PR
                Plane straddling could be tough


        Static grid octree or quadtree

                Invariants
                        Each entity is in exactly ONE cell
                        This cell is the smallest that contains the entity

                For each moving entity
                        While the entity is NOT within its current cell
                                Move it up (necessary)

                        If the entity fits within a subcell of the current cell
                                Move it down (optimization)

                Entities outside the static index
                        Sit at the root
                                Root is infinitely large
                or
                        Can't happen
                                ODE planes bound the space
                                This would also allow quadtree space to work

-------------------------------------------------------------------------------


  (\_
 ()_

  (\_
 (]_

  (\
 (]_

  (\
 [)_

  (\
 []_

  (\
 [)_ THUMB

