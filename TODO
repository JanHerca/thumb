Convert light and camera entity draw to use OBJ
Consider collapsing dark and lite shaders
    Do ambient and emission in the shader
    Zero ambient and emission for all but first lightsource
    This would enable single pass rendering in single-light scenes
Lay-down-depth?
    It's a much stronger guarantee than front-to-back sort
    It's double speed on NVIDIA
    Be CAREFUL about valid state.  Perf and be sure.
Reduce the number of GL state changes in OBJ
    move client state enables into scene draw
    set mutable state in the props
    don't push attribs
    Assumption: if an MTL does not specify a value, then it doesn't care
        about that value and can tolerate unexpected state
Reduce the number of string passes by value in the gui module.
Remove the shadowmap state ownership from the scene.
Move the draw priority sort out of the main draw.
    It changes only when the scene changes.
    Maybe generate a linear list of visible stuff?
        This is advantageous in multipass
Restructure the prep/prio/draw system
    Work out the spatial partition first
    Draw order is crucial
    Consider CSM and reflection/refraction rendering.

Out of curiousity, perf the vert padded out to power of two.

General
    read gotw.ca/gotw
        #54 shrinking vectors

Control panes on function keys?
    F5 info about
    F6 info world
    F7 info solid
    F8 info joint

Add entity scaling.
    Uniform only?
        + would preserve sphereness of spheres
        + would ensure texture uniformity
        - would force a variety of sized OBJs
Add new ODE geoms.
    Cylinder
    Capsule
    Heightfield
    Plane
    Convex?
    Ray?
Add DDS support
    Cube map load
    DXT load
    Mipmap load
Incorporate some of the shading/buffer/image/state lessons learned from atmo.
Incorporate perf module from atmo.  Stats in GUI?
Generalize the "follow" mechanism to "enable".
Move sky/earth/sun ownership to scene.
Use spatial index to eliminate unnecessary shadow map redraw.
    Lights should know if they see a static scene.

Tune the near and far clipping planes.
Frustum culling for cameras and lights.
Water.
    Bouyancy force.
    Optional GPU ripple integrator.
    Changable water depth?
Skeletal animation.
Cascaded shadow.
Documentation.
Rubber-band select.
Object-inside-object select?
Intro text / flowing widget.
World parameters
Selection registers.
Center contraint on a group.
Partial run.
Refresh button on finder.
    Make Up button nicer.
    Icon view.
Optimize constraint drawing -- integrate display lists with glob?  Use OBJ?
Optimize wire drawing.
Conveyer solid property.
Static / package data archives with Z compression.
Figure out why repeated runs differ.
    Body order?

"scene" -> "world"?
"demo"  -> ?

Stop the freerun during editing.
        Snapshot beneath info.
OBJ support:
    map wrapping
    map scale and translate

Data archives

    a common path naming scheme that transparently accesses all archives
    in prioritized order

    priority
        cwd    rw
        home   rw
        pak2   r
        pak1   r
        pak0   r
        static r

    load searches r archives in order
    save searches w archives in order

file
pack
link

