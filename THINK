Thumb features to consider

   Rewrite the GUI mechanism
       to use a glyph map instead of a wordmap
       to use VBOs instead of immediate mode

   loading zipped data files
      XML
      OBJ
          get some more canonical examples
              bunny
              happy buddha
              dragon
              tweety
              armadillo

    Grab the pointer during play mode
        this would allow modular control modalities
            3rd person control
            neverball tilt
            car driving

    Replay mode will need to be strong
        support demo and benchmarking
        two approaches 
            1 capture all the events
                this is easy, since they dist mechanism is in place
                the physics will not be reproducible
            2 capture the state of the physical system
                this will lead to BIG replays
                the physics SHOULD be reproducible
                records only play mode
                would allow REWIND!

    Allow the execution of the physical system to be a "change" to the world
        Represent it as a set of transforms and it can be undoable

    Rework the GUI to use the pool.
        Atlas the glyphs; forget about the words.

    Consider multithreading
        Pipelining?
        Double-buffering data?
           The node-local transform cache is already a doubled buffer?
        Backgrounded data loading?

+   Normal display renders directly to the on-screen framebuffer?

    It would be nice to have an #ifdef mechanism in the shaders
        This would make it easier to produce modal shaders without
        explicit conditionals.
            Debug view modes
            Capability fallbacks

    Modify the data object to note the most recently used directory
        auto-associates MTLs with OBJs
        simplifies the glsl include mechanism

    It's NOT completely reasonable to demand GFFX or GLSL

    Valve's distance-alpha texturing is killer
        It allows GUI text to scale to Varrier/LambdaVision
        It allows foliage to fade in and out with distance

+   HDR
+       float16
+       AGC optional
+       Bloom optional
+       Be sure to allow for fallback

    Adaptive terrain

    Skinning
        Automatic generation of ODE capsules to fit bones

    New sky
        clouds?
            http://www.gamedev.net/community/forums/topic.asp?topic_id=86024
        Should be efficient to render into a cubemap per frame

+   Take a serious look at state reloading
+       start/close

    Particle systems
        Clouds
        Smoke
        Puffs of dust at physical collision
        Snow
        Rain
        Definitely based on point sprites
            No fallback is strictly necessary
        Possibly with normal maps
        Possibly with physics interaction
            Explosion debris
        Possibly animated on smoothed vector field
            Leaves

    Grass
        Coverage-map-based
        Is grass just a form of particle?

    Fur

    Are there any opportunities for scissor-rectangle optimizations?

    SSAO/SSDO
        Depth unsharp mask is cheaper, with fewer artifacts
            Not physically correct, but may be a nice visual effect
        Would definitely add detail to shadowed areas
        May require linear depth (float16)
        (cliche/hacky?)

    Vertex Array Object
        easy fallback

    If all rendering is confined to pool, then GL 1, 2, and 3 profiles
    should be easy to implement.

-------------------------------------------------------------------------------

Binding needs

    color mode
        program.xml

        texture name and file name
        texture name and procedural name
            (this allows shaders to rename procedurals)
        uniform name and procedural name

    depth mode
        program.xml
        ...

Program needs
    sampler
        name
        unit
        proc
            shadow
            diffuse_irradiance
            specular_irradiance
        extra
    uniform
        name
        value
            shadow_map_split
            view_matrix
            view_inverse         (This will enable the GL3 transition)

    attribute name and location

Currently...
    program sampler name may be special -- THIS IS WRONG
            shadow0
            shadow1
            shadow2
            env_diffuse
            env_specular
            ...


-------------------------------------------------------------------------------

Input:

    The environment map
        L           RGB nxn cube map (arbitrary format)

    Spherical harmonics basis Ylm(N) (a scalar) for all normals N
        Y00(N)     (this one is a constant)

        Y1+1(N)
        Y10(N)
        Y1-1(N)

        Y2-2(N)
        Y2-1(N)
        Y20(N)
        Y2+1(N)
        Y2+2(N)     8 nxn cube-mapped scalars

        These can ALL be computed at run time.

    Solid angle of each cube map texel 
        dw          1 nxn cube-mapped scalar


Intermediate

    In order to Sum L(N) * Ylm(N) * dw(N) for all N
        Giving 9 RGB values...

    nxn texture
        First pass, make 6x2 texture accesses
            swizzle XYZ to permute the normal from nxn to all N.
            get L(N)
            get dw(N)
            compute Ylm(N)

        Log2(n) passes: quad parallel reduction of the nxn texture


*** SOMEHOW collect these 9 values from the 9 textures ***
    Do this in a generalizable fashion in order to accommodate more than
    2 bands of spherical harmonics

Final cubemap generation

    For each of 6 mxm faces

        compute N
        compute E(N) from equation (11) Hanrahan

    It may be advisable to do this in a (m+2)x(m+2) buffer and
    PBO glTexSubImage the data into a bordered cube map.

    ATI's edge fudge may work out

    Or a really bletchy hack: the cube map faces could simply be stretched
    such that the edge pixels actually fall in the crack.  This would
    guarantee that the edges of adjacent faces match up.


-------------------------------------------------------------------------------

Rendering:

    Binding manages static environment maps

    If the environment changed
        World asks the binding for an environment map
        World renders 6 views of the sky

        Binding manages the computation of diffuse env map from specular

    Each individual binding knows what texture names to bind to env maps

-------------------------------------------------------------------------------

target display size      1920 1080

offscreen render size    1280  720

render to buffer         1280  720          -> src
1  downsample to buffer   640  360     src  -> blur    downsample
2  downsample to buffer   320  180     blur -> ping    downsample
3  downsample to buffer   160   90     ping -> pong    downsample
4  downsample to buffer    80   45     pong -> ping    downsample
5  downsample to buffer    40   23     ping -> pong    downsample
6  downsample to buffer    20   12     pong -> ping    downsample
7  downsample to buffer    10    6     ping -> pong    downsample
8  downsample to buffer     5    3     pong -> ping    downsample
9  downsample to buffer     3    2     ping -> pong    downsample
10 downsample to buffer     2    1     pong -> ping    downsample
11 downsample to buffer     1    1     ping -> pong    downsample

horizontal gaussion       640  360     blur -> ping    h_gaussian
vertical   gaussion       640  360     ping -> blur    v_gaussian

finish                   1280  720     src + pong + blur -> dst tonemap

-------------------------------------------------------------------------------

Passing the viewport in the vertices of the quad would eliminate the need to use frag_k frag_d

smoothstep a quad in sphere coords
compute user_frust
inverse user_frust in dome-draw

frustum object

    eye space positions
    can compute/use world positions
    knows its XML dom
        can take FOV and tweaks
        can take calibration input events
    knows its eye index
        can take a list of eyes
        can recompute it's planes based on (tracked) eye
            for both projection determination
            and culling
    can create frustum based on horizon
        and add it to the list of frusta being passed around
    can test aabb
    can test shell
    can provide frusta points and/or splits and/or split bound frusta
        for correct shadow rendering
    can provide LOD info at a point?
        what does that mean exactly?

    the code that computes the eye frustum of a dome segment could be the same that computes the light frustum of a split

uses
    sphere->view
    patch->view
    pool->view

-------------------------------------------------------------------------------

complete the transition to the serial module

make cnt::control seek the right size, so that the GUI need not be asked
set the GUI transform before gui draw is called
    try to abstract the 2Dness of the gui away

* Add the transform business to the dialog?
    dialog::point takes (p, q)
    would enable different dialogs with different transforms

-------------------------------------------------------------------------------

accumulate a list of frusta
    host asks each tile to prep
        tile asks each disp to prep
            disp looks at views
            disp comptutes/provides view frustum pointers
    host asks scene to prep given frusta
    host asks each tile to draw
        tile asks each disp to draw
            disp looks at views
            disp asks scene to draw off-screen given a frustum
            disp draws processed view on-screen

disps
    normal
    varrier
    anaglyph
    dome
    scanline
    idesk4 (flip)

-------------------------------------------------------------------------------

Cracking may be occuring because one interpolant is k while the other is k-1

-------------------------------------------------------------------------------
