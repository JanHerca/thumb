Thumb features to consider

    It would be nice to have an #ifdef mechanism in the shaders
        This would make it easier to produce modal shaders without
        explicit conditionals.
            Debug view modes
            Capability fallbacks

    Modify the data object to note the most recently used directory
        auto-associates MTLs with OBJs
        simplifies the glsl include mechanism

    It's NOT completely reasonable to demand GFFX or GLSL

    HDR
        float16
        AGC optional
        Bloom optional
        Be sure to allow for fallback

    Adaptive terrain

    New sky
        clouds?
            http://www.gamedev.net/community/forums/topic.asp?topic_id=86024
        Should be efficient to render into a cubemap per frame

    Take a serious look at state reloading

    Replay
        (this is crucial)
        Performance testing and benchmarking

    Particle systems
        Clouds
        Smoke
        Puffs of dust at physical collision
        Snow
        Rain
        Definitely based on point sprites
            No fallback is strictly necessary
        Possibly with normal maps
        Possibly with physics interaction
            Explosion debris
        Possibly animated on smoothed vector field
            Leaves

    Grass
        Coverage-map-based
        Is grass just a form of particle?

    Skinning
        Automatic generation of ODE capsules to fit bones

    Fur

    Are there any opportunities for scissor-rectangle optimizations?

    SSAO/SSDO
        Depth unsharp mask is cheaper, with fewer artifacts
            Not physically correct, but may be a nice visual effect
        Would definitely add detail to shadowed areas
        May require linear depth (float16)
        (cliche/hacky?)

    Vertex Array Object
        easy fallback

    If all rendering is confined to pool, then GL 1, 2, and 3 profiles
    should be easy to implement.

-------------------------------------------------------------------------------

Passing the viewport in the vertices of the quad would eliminate the need to use frag_k frag_d

smoothstep a quad in sphere coords
compute user_frust
inverse user_frust in dome-draw

frustum object

    eye space positions
    can compute/use world positions
    knows its XML dom
        can take FOV and tweaks
        can take calibration input events
    knows its eye index
        can take a list of eyes
        can recompute it's planes based on (tracked) eye
            for both projection determination
            and culling
    can create frustum based on horizon
        and add it to the list of frusta being passed around
    can test aabb
    can test shell
    can provide frusta points and/or splits and/or split bound frusta
        for correct shadow rendering
    can provide LOD info at a point?
        what does that mean exactly?

    the code that computes the eye frustum of a dome segment could be the same that computes the light frustum of a split

uses
    sphere->view
    patch->view
    pool->view

-------------------------------------------------------------------------------

complete the transition to the serial module

make cnt::control seek the right size, so that the GUI need not be asked
set the GUI transform before gui draw is called
    try to abstract the 2Dness of the gui away

* Add the transform business to the dialog?
    dialog::point takes (p, q)
    would enable different dialogs with different transforms

-------------------------------------------------------------------------------

accumulate a list of frusta
    host asks each tile to prep
        tile asks each disp to prep
            disp looks at views
            disp comptutes/provides view frustum pointers
    host asks scene to prep given frusta
    host asks each tile to draw
        tile asks each disp to draw
            disp looks at views
            disp asks scene to draw off-screen given a frustum
            disp draws processed view on-screen

disps
    normal
    varrier
    anaglyph
    dome
    scanline
    idesk4 (flip)

-------------------------------------------------------------------------------

Cracking may be occuring because one interpolant is k while the other is k-1

-------------------------------------------------------------------------------
