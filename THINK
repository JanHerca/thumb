smoothstep a quad in sphere coords
compute user_frust
inverse user_frust in dome-draw


-------------------------------------------------------------------------------

rotate y around global y axis
rotate p around local  x axis
rotate r around local  z axis

translate r down global z axis
rotate    p around global x axis
rotate    t around global y axis

or

rotate r around global z axis
rotate p around global x axis
rotate y around local  y axis

translate r down global z axis
rotate    p around global x axis
rotate    t around global y axis

-------------------------------------------------------------------------------

complete the transition to the serial module

make cnt::control seek the right size, so that the GUI need not be asked
set the GUI transform before gui draw is called
    try to abstract the 2Dness of the gui away

* Add the transform business to the dialog?
    dialog::point takes (p, q)
    would enable different dialogs with different transforms

-------------------------------------------------------------------------------

accumulate a list of frusta
    host asks each tile to prep
        tile asks each disp to prep
            disp looks at views
            disp comptutes/provides view frustum pointers
    host asks scene to prep given frusta
    host asks each tile to draw
        tile asks each disp to draw
            disp looks at views
            disp asks scene to draw off-screen given a frustum
            disp draws processed view on-screen

disps
    normal
    varrier
    anaglyph
    dome
    scanline
    idesk4 (flip)

-------------------------------------------------------------------------------

view has
    frustum
    frame

It's not necessary to have a frame per view-tile
    per view is sufficient
    thus the host owns the frames?

view.draw
        calls prog->draw
        	passes frustum?              
        returns frame

tile.draw
        mode.draw
                passes frames
                passes frusta?

viewport object
    takes a prog and supplies frag bias and offset

OR just assume all rendering is done offscreen?
    simplifies sphere draw

mode::normal.draw
    calls prog->draw with frustum
    draws screen rect

mode::varrier.draw
    does left view setup
    calls prog->draw with left view frustum
    does right view setup
    calls prog->draw with right view frustum
    draws screen rect

mode::dome.draw
    extracts view-center frustum
    call prog->draw with view-center frustum
    draws screen rect


the prep frusta are wrong for dome mode
set_head sets the user frustum, not the projector frustum

gl_FragCoord gives wrong values when rendering direct to screen


-------------------------------------------------------------------------------

Host abstraction

    host object
        takes a name tag
        loads XML config
            defines the client/server status
                if this host is a client, listen for a connection
                if this host has clients, connect a socket to each

    main loop
        if this host is not a client
            SDL event loop
                submit each event to the host object
                    forward the event to the prog
                    send to all clients
        else
            select on the incoming socket
                submit each event to this
                    forwand the event to the prog
                    send to all clients

events
    track(d, p, v)
    stick(d, x, y)
    point(x, y)
    click(b, d)
    keybd(k, d)
    timer(dt)
    paint()   wait for response... swap
    close()   wait for response... exit

-------------------------------------------------------------------------------

Cracking may be occuring because one interpolant is k while the other is k-1


Bouncing between eyes and tiles screws with patch hierarchy coherence
    nearly all leaves are invalidated when the tile changes

define a plural frame buffer?
    give an array of
        view frustum planes
        view point
        frame area
    frustum union planes

for each patch
    given the sphere area (normal and radius)
    determine the eye area (x0 y0 x1 y1)
    determine the frame area (x0 y0 x1 y1)
    determine the pixel density (sphere area / frame area)

    for each geomap
        for each tile touching the sphere area
            with at least the maximum pixel density
            enqueue texture object and frame area

    for each queued texture object
        render all frame areas (or just the union of all frame areas?)


send [sphere area, frame rect] pairs to the root of the geomap
    let tiles accumulate rects
draw the geomap

(this could enable smart LOD blending)


-------------------------------------------------------------------------------

Rationalle: Don't count VRAM usage and buffer storage separately.
    Just let the GL handle it.
    The GL can reload its own internal buffers faster anyway
    Don't keep buffers.  Delete after upload.  Reduces redundancy


A file request is
    a filename
    a pointer to a tile
    a pointer to a geomap?

A file response is
    a pixel buffer
    a pointer to a tile

* test and data request need to be combined...

A tile is presented with a sphere area and screen area
    if the sphere area overlaps with this tile's sphere area
        if this tile is a leaf or its density is greater than requested
            I'm it
        if I'm not it send the areas to any/all children
        if none of them are it
            I'm it
        if I'm it
            push this tile on the draw stack
            add the screen area to this tile's draw area

A tile needs to draw itself
    append self onto the geomap LRU queue

    if state is ejected
        acquire the geomap static queue mutex
        enqueue the file request in the geomap static request queue
        release the geomap static queue mutex
        post the request queue semaphore
        set state to waiting

    if state is ready
        bind the texture

A tile is issued a texture object
    store it
    set state to ready

A tile is ordered to eject
    delete the texture object
    set state to ejected

geomap cycle responses
    while response queue is not empty

        while the geomap local texture quantity is too large
           pop head of LRU tile queue
           order LRU tile to eject
           update the geomap local texture quantity

        upload the texture
        update the geomap texture quantity

        issue the texture object to the tile

geomap load thread
    loop
        wait on the request queue semaphore
        acquire the geomap static request queue mutex
        pop the request from the queue
        release the geomap static request queue mutex

        load the file

        wait on the respond queue semaphore
        acquire the geomap static respond queue mutex
        move the file to the response queue buffer
        release the geomap static respond queue mutex


request queue semaphore indicates number of used requests
respond queue semaphore indicates number of free load slots



0   1300 650 512    0  0                   3  2
1   650 650 512      0  0   0  1
2   325 325 512      

